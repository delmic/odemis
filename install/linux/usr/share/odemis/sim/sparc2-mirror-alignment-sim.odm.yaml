# Configuration for the SPARC v2:
# * Bay1 module: VISNIR
# * Bay2 module: none
{
SPARC2-VIS: { # Placeholder names, change to module name(s)
    class: Microscope,
    role: sparc2,
},

# Light (lamp with known spectrum)
"Calibration Light": {
    class: light.Light,
    role: "brightlight",
    power_supplier: "Power Control Unit",
    affects: ["Camera", "Spectrometer"],
},

"Power Control Unit": {
    class: powerctrl.PowerControlUnit,
    role: "power-control",
    init: {
        port: "/dev/fake",
        pin_map: {
            "Camera": 0, # change this to the right camera name
            "Spectrograph": 2, # no spectograph in SPARC Compact
            "Optical Actuators": 4,
            "CL PMT control unit": 5,
            "Calibration Light": 6,
        },
        delay: { # Time it takes before a component is accessible
            "Camera": 2,
            "Spectrograph": 3,
            "Optical Actuators": 1,
            "CL PMT control unit": 0,
            "Calibration Light": 1, # To turn on/off the light, it's immediate
        },
        init: { # Which component to power on from the very beginning (to save time)
            "Camera": True,
            "Spectrograph": True,
            "Optical Actuators": True,
            "CL PMT control unit": False,
            "Calibration Light": True, # turn if on initially, to warm up. It will automatically be off when the component starts
        },
        termination: { # Which component to power off when closing Odemis (otherwise they stay in the current state)
            "Calibration Light": False,
            # "Camera": False,
            "Spectrograph": False,  # To force the spectrograph read the turret again if it's changed
            # "Optical Actuators": False,
        },
        # List of EEPROM IDs (of the plates in bay1 and bay2) which are required to start properly
        ids: [],
    }
},

# Control the E-beam through analog external X/Y connection, using a DAQ board
# Control the settings of the E-beam, stage movement, mag/focus through the API

"SEM Scan Interface": {
    class: semcomedi.SEMComedi,
    role: null,
    init: {
        device: "/dev/comedi0"
    },
    # more detectors can be added, if necessary
    children: {
       scanner: "SEM E-beam",
       detector0: "SEM Detector Analog",
       detector1: "CL PMT Analog",
       #counter0: "Monochromator Analog",
    },
},

# Connect:
# X -> AO 0
# Y -> AO 1
# Ground -> AO GND
"SEM E-beam": {
    role: null,
    init: {
        channels: [1, 0],
        max_res : [4096, 2732],
        # On Delmic scanning box v2, the voltage is x2, so need to specify twice smaller values than needed.
        limits: [[-2.67, 2.67], [1.79, -1.79]],  # V
        park: [-2, -2], # V
        # Digital output port mapping on the Delmic scanning box v2:
        # 0 = Relay
        # 1 = Open drain output (Y0.0)
        # 2 = Digital Out 1
        # 3 = Digital Out 0
        # 4 = Status led
        scanning_ttl: {4: True}, # output ports -> True (indicate scanning) or False (indicate parked)
        settle_time: 10.e-6, # s
        hfw_nomag: 0.400 #0.114, # m, must be the same as in "XT E-Beam Control"
    },
},

# Must be connected on AI1/AI9 (differential)
"SEM Detector Analog": { # aka ETD
    # Internal child of SEM Scan Interface, so no class
    role: null,
    init: {
        channel: 1,
        limits: [-5, 5], # V
    },
},

# Must be connected on AI0/AI8 (differential)
"CL PMT Analog": { # the raw detector of the PMT
    role: null,
    init: {
        channel: 0,
        limits: [-2.5, 2.5], # V
    },
},

"SimSEM": {
    class: simsem.SimSEM,
    role: null,
    init: {
        image: "simsem-fake-output.h5", # any large 16 bit image is fine
    },
    children: {
        scanner: "XT E-beam Control",
        detector0: "Sim SE Detector",
        focus: "XT E-beam Focus",
    },
},

"XT E-beam Control": {
    role: null,
    init: {},
},

"XT E-beam Focus": {
    role: ebeam-focus,
    init: {},
    affects: ["SEM E-beam Full"],
},

# Unused, but needed to make the SimSEM happy
"Sim SE Detector": {
    role: null,
    init: {},
},

# Normally provided by the SEM
"XT Stage": {
    class: tmcm.TMCLController,
    role: stage,
    init: {
        port: "/dev/fake6",
        address: null,
        axes: ["x", "y", "z", "rx", "rz"],
        ustepsize: [1.e-7, 1.e-7, 1.e-7, 1.2e-5, 1.2e-5], # unit/µstep
        rng: [[-0.1, 0.1], [-0.05, 0.05], [0, 0.1], [-2, 2], [0, 6.28]],
        unit: ["m", "m", "m", "rad", "rad"],
        refproc: "Standard",
    },
    affects: ["Camera", "Spectrometer", "CL Detector", "SEM E-beam Full"],
},

# Merges the scan interface e-beam and the e-beam control (via API)
"SEM E-beam Full": {
    class: scanner.CompositedScanner,
    role: e-beam,
    init: {
    },
      children: {
        detector0: "SEM Detector",
        detector1: "CL PMT",
    },
    dependencies: {
        external: "SEM E-beam",
        internal: "XT E-beam Control"
    },
    properties: {
        scale: [8, 8], #  (ratio) : start with a pretty fast scan
        dwellTime: 10.e-6, # s
    },
    # affects the CCD in case of cathodoluminescence
    affects: ["SEM Detector", "CL Detector", "Camera", "Spectrometer"],
},

# Wraps the detectors, so that the "external" mode is set automatically when acquiring
"SEM Detector": {
    role: se-detector,
    dependencies: {
        external: "SEM Detector Analog",
    },
    init: {},
},

"CL PMT": {
    role: null,
    dependencies: {
        external: "CL PMT Analog",
    },
    init: {},
},

# The first lens of Plate 1, able to move along the whole range
"Lens1 Mover": {
    class: actuator.MultiplexActuator,
    role: "lens-mover",
    dependencies: {"x": "Optical Actuators"},
    init: {
        axes_map: {"x": "l1"},
        ref_on_init: ["x"],
    },
    metadata: {
        # Default position of the lens (can be improved by user)
        FAV_POS_ACTIVE: {"x": 0.0290955686} # m
    },
    affects: ["Lens2 Switch"],
},

# The second lens of Plate 1, either to working or parking position
"Lens2 Switch": {
    class: actuator.MultiplexActuator,
    role: "lens-switch",
    dependencies: {"x": "Optical Actuators"},
    init: {
        axes_map: {"x": "l2"},
        ref_on_init: ["x"],
    },
    metadata: {
        # Position away
        FAV_POS_DEACTIVE: {"x": 0.0}, # m
        # Default position of the lens (can be improved by user)
        FAV_POS_ACTIVE: {"x": -0.0499320073}, # m
        POS_ACTIVE_RANGE: {"x": [-1.e-3, 1.e-3]},  # relative min/max from the active position when doing EK-scanning
    },
    affects: ["Camera", "Spectrometer", "CL Detector"],
},

# Controller for the motors moving the various parts of the optical box
"Optical Actuators": {
    class: tmcm.TMCLController,
    role: null,
    power_supplier: "Power Control Unit",
    init: {
        port: "/dev/fake6",
        address: null,
        # param_file: "/usr/share/odemis/sparc2-atm-tmcm6110-pmt.tmcm.tsv",
        axes: ["l1", "l2", "cl-sel", "fw", "slit"],
        # These values only need to be roughly correct
        ustepsize: [25.1e-7, 25.1e-7, 26.1e-7, 3.392e-5, 5.e-7], # m/µstep  # Special value for the simulator to go faster
        rng: [[-1.e-3, 100.e-3], [-1.e-3, 100.e-3], [-1.e-3, 100.e-3], [-14, 14], [-1.e-3, 2.e-3]],  # very rough ranges, which should be correct for any module
        unit: ["m", "m", "m", "rad", "m"],
        refproc: "Standard",
        refswitch: {"l1": 0, "l2": 0, "cl-sel": 4, "fw": 4},
        inverted: ["l2"],
    },
},

# Mirror in Plate 2, selects between spectrometer and cl-detector
"CL Selector": {
    class: actuator.FixedPositionsActuator,
    role: "cl-det-selector",
    dependencies: {"x": "Optical Actuators"},
    init: {
        axis_name: "cl-sel",
        positions: {
            0.003: ["CL Detector"],
            0.036: ["Spec CCD Flipper"]
        },
    },
    affects: ["Spec CCD Flipper", "CL Detector"],
},

"CL Filter Wheel": {
    class: actuator.FixedPositionsActuator,
    role: cl-filter,
    dependencies: {"band": "Optical Actuators"},
    init: {
        axis_name: "fw",
        # It supports up to 8 filters
        positions: {
            # pos (rad) -> m,m
            0.33920:       "pass-through",     # 1
            1.12460:       [375.e-9, 425.e-9], # 2
            1.91000:       [425.e-9, 475.e-9], # 3
            2.69539:       [475.e-9, 525.e-9], # 4
            3.48079:       [525.e-9, 575.e-9], # 5
            4.26619:       [575.e-9, 625.e-9], # 6
            5.05159:       [625.e-9, 675.e-9], # 7
            5.83699:       [675.e-9, 725.e-9], # 8
        },
        cycle: 6.283185, # position of ref switch (0) after a full turn
    },
    affects: ["CL Detector"],
},

"Camera": {
    class: simcam.Camera,
    role: ccd,
    power_supplier: "Power Control Unit",
    init: {
        image: "sparc-ar-mirror-aligned-pos.h5",  # only for simulator
    },
    dependencies: {
        focus: "Spectrograph focus",
        mirror: "Mirror Actuators",
        stage: "XT Stage",
    },
},

# Spectrometer = Newton + Shamrock SR193 (connected via USB)
"Spectrometer": {
    class: spectrometer.CompositedSpectrometer,
    role: spectrometer0,
    dependencies: {detector: "Camera", spectrograph: "Spectrograph"},
    init: {
        transp: [1, 2],
    },    
    properties: {
        #binning: [4, 256],
    },
},

"Optical Path Properties": {
    class: static.OpticalLens,
    role: lens,
    # high NA working distance mirror config
    init: {
       # TODO: put the right values for mag and rotation
       mag: 0.338, # ratio
       na: 0.2, # ratio, numerical aperture
       ri: 1.0, # ratio, refractive index
       # Add to have support for AR, disable in case of SPARC Compact
       pole_pos: [512, 128], # (px, px), position of the pole (aka the hole in the mirror)
       # Add to have support for EK, disable in case of SPARC Compact
       mirror_pos_top: [220, 0],  # (px, px/m), position of the top of the mirror depending on the wavelength
       mirror_pos_bottom: [30, 0],  # (px, px/m), position of the bottom of the mirror depending on the wavelength
       x_max: 13.25e-3,  # m, the distance between the parabola origin and the cutoff position
       hole_diam: 0.6e-3,  # m, diameter the hole in the mirror
       focus_dist: 0.5e-3,  # m, the vertical mirror cutoff, iow the min distance between the mirror and the sample
       parabola_f: 2.5e-3,  # m, parabola_parameter=1/4f
       # TODO: update for the SEM (as angle between the SEM Y axis and the ATM)
       rotation: 0, # rad, -1.570796326795: 90° rotation between optical axis and SEM Y axis (declared in the interface kit)
    },
     # enable persistent if there is a single mirror used
#    persistent: {
#        properties: [polePosition, mirrorPositionTop, mirrorPositionBottom],
#    },
    affects: ["Camera", "Spectrometer"],
},

# Controller for moving the stage Box
# Note: the S axis can _only_ be moved when the l axis is near the active/engaged position
"Mirror Actuators": {
    class: tmcm.TMCLController,
    role: "mirror",
    init: {
        port: "/dev/fake6",
        address: null,
        axes: ["l", "s"],
        ustepsize: [1.e-6, 1.e-6], # m/µstep
        refproc: "Standard",
        refswitch: {"s": 0, "l": 0},
        rng: [[0.e-3, 255.e-3], [-5.e-3, 5.e-3]],
    },
    metadata: {
        # Default position of the mirror engaged (will be improved during alignment)
        #AXES_ORDER_REF: ["s", "l"],
        FAV_POS_ACTIVE: {"l": 0.20792998299999998, 's': 0.0017800240999999999},  # m, m
    },
},

# Internal component to convert between the referential of the mirror actuators
# and the X/Y referential of the SEM. Used by the mirror alignment functions.
"Mirror Actuators in XY referential": {
    class: actuator.ConvertStage,
    role: mirror-xy,
    dependencies: {"orig": "Mirror Actuators"},
    init: {
        axes: ["l", "s"], # mapped respectively to X, Y
        # TODO: to be measured (so that in the alignment tab, moving in X only moves horizontally in the SEM image)
        rotation: 2.37365 # rad (= 136°)
    },
},

"Spectrograph": {
    class: andorshrk.Shamrock,
    role: spectrograph,
    power_supplier: "Power Control Unit",
    init: {
        device: "fake",
        slits: {1: "slit-in", # INPUT_SIDE
        },
        bands: { # The filters in the filter-wheel
            1: "pass-through", # pos -> name or min,max (m)
            2: [475.e-9, 525.e-9],
            3: [525.e-9, 575.e-9],
            4: [575.e-9, 625.e-9],
            5: [625.e-9, 675.e-9],
            6: [675.e-9, 725.e-9],
        },
        fstepsize: 30.e-6, # m, size of one focus step
        drives_shutter: [0] # flipper positions: the Newton Camera drives the shutter
    },
    affects: ["Camera", "Spectrometer"],
},

"Spectrograph focus": {
    class: actuator.MultiplexActuator,
    role: "focus",
    dependencies: {"z": "Spectrograph"},
    init: {
        axes_map: {"z": "focus"},
    },
    affects: ["Camera", "Spectrometer"],
},

# Provide the mirror (aka port selector) of the spectrograph as a separate component
"Spec CCD Flipper": {
    class: actuator.FixedPositionsActuator,
    role: "spec-det-selector",
    dependencies: {"rx": "Spectrograph"},
    init: {
        axis_name: "flip-out",
        positions: {
            0: ["Camera", "Spectrometer"],
            1.5707963267948966: [],
        },
    },
    affects: ["Camera", "Spectrometer"],
},

# Provide the filter wheel of the spectrograph as a separate component
"Spec Filter Wheel": {
     class: actuator.MultiplexActuator,
     role: filter,
     dependencies: {"band": "Spectrograph"},
     init: {
         axes_map: {"band": "band"},
     },
     affects: ["Camera", "Spectrometer"],
},

# Control the slit position to either fully-open or small (dependent on the spectrometer slit-in)
"Slit": {
    class: actuator.FixedPositionsActuator,
    role: "slit-in-big",
    dependencies: {"x": "Optical Actuators"},
    init: {
        axis_name: "slit",
        positions: {
            -0.00013: "on", # fully opened
            0.00115: "off", # opening based on the small slit
        },
    },
    affects: ["Camera", "Spectrometer"],
},

}
