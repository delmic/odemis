#!/usr/bin/env python3
# Attempt to park the mirror of the SPARCv2, even if no backend is running
"""
Created on October 2015

@author: Éric Piel

Copyright © 2015-2026 Éric Piel, Delmic

Odemis is free software: you can redistribute it and/or modify it under the terms
of the GNU General Public License version 2 as published by the Free Software
Foundation.

Odemis is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
Odemis. If not, see http://www.gnu.org/licenses/.
"""

import argparse
import logging
import os
import sys
import threading
from concurrent.futures import CancelledError, Future
from dataclasses import dataclass
from typing import Optional, Tuple

import Pyro4
import wx

from odemis import model
from odemis.driver import tmcm

TEST_NOHW = (os.environ.get("TEST_NOHW", "0") != "0")  # Default to real HW

# Standard way to configure the TMCM board handling the Redux stage
REDUX_KWARGS = {
    "port": "/dev/ttyTMCM*",
    "address": 4,
    "axes": ["s", "l"],
    "ustepsize": [5.9e-9, 5.9e-9],  # m/µstep (doesn't really matter here)
    "refproc": "Standard",
    "refswitch": {"s": 0, "l": 0},
}

if TEST_NOHW:
    # Test using the simulator
    REDUX_KWARGS["port"] = "/dev/fake6"
    REDUX_KWARGS["address"] = None


@dataclass
class FutureHolder:
    """Mutable container for sharing a Future between threads, enabling cancellation."""
    future: Optional[Future] = None


@dataclass
class ParkState(FutureHolder):
    """Shared state for the GUI parking operation: current future and any exception raised."""
    error: Optional[Exception] = None


def park(mirror: model.Actuator, future_holder: Optional[FutureHolder] = None) -> None:
    # Need to park in two moves: first S, then L
    f = mirror.reference({"s"})
    if future_holder is not None:
        future_holder.future = f
    logging.info("Parking the mirror...")
    try:
        logging.debug("Moving S axis")
        f.result()  # Can raise CancelledError if cancelled, or other exceptions if move failed
    except KeyboardInterrupt:
        f.cancel()
        logging.warning("Cancelled parking move")
        raise CancelledError()

    f = mirror.reference({"l"})
    if future_holder is not None:
        future_holder.future = f
    try:
        logging.debug("Moving L axis")
        f.result()
    except KeyboardInterrupt:
        f.cancel()
        logging.warning("Cancelled parking move")
        raise CancelledError()


def get_mirror() -> Tuple[model.Actuator, bool]:
    """
    Get the mirror component, either from the backend or directly from the hardware.

    :return:
      mirror: The mirror component
      should_terminate: a boolean indicating whether the component should be terminated when not used
       anymore by the caller (False if it was obtained from the backend)
    :raises: Various exceptions if the mirror cannot be accessed
    """
    try:
        mirror = model.getComponent(role="mirror")
        logging.debug("Using the backend to park the mirror")
        return mirror, False  # False indicates we got it from the backend
    except (Pyro4.errors.CommunicationError, LookupError):
        logging.info("Failed to access the backend, will try directly")
        mirror = tmcm.TMCLController("Mirror stage", "mirror", **REDUX_KWARGS)
        logging.info("Connected to %s", mirror.hwVersion)
        return mirror, True  # True indicates we got a direct connection


def do_park_mirror(future_holder: Optional[FutureHolder] = None) -> None:
    """
    Execute the mirror parking operation.

    :param future_holder: Optional FutureHolder to store the current future,
        allowing external cancellation.
    :raises: Various exceptions from park()
    """
    mirror, must_terminate = get_mirror()
    try:
        park(mirror, future_holder)
    finally:
        if must_terminate:
            mirror.terminate()


class ProgressDialog(wx.Dialog):
    """
    Dialog showing an indeterminate progress bar during mirror parking operation.
    """

    def __init__(self, parent: Optional[wx.Window] = None, future_holder: Optional[FutureHolder] = None):
        """
        Initialize the progress dialog.

        :param parent: Parent window (None for top-level)
        :param future_holder: Optional FutureHolder to store the current future,
            allowing cancellation from the Cancel button.
        """
        super().__init__(parent, title="Parking Mirror",
                         style=wx.CAPTION)  # No close button, so user can't hide the progress bar
        self._future_holder = future_holder

        # Create UI elements
        panel = wx.Panel(self)
        sizer = wx.BoxSizer(wx.VERTICAL)

        # Status text
        text = wx.StaticText(panel, label="Parking mirror, please wait...")
        sizer.Add(text, 0, wx.ALL | wx.ALIGN_CENTER, 10)

        # Progress gauge (indeterminate)
        self.gauge = wx.Gauge(panel, range=100, size=(300, 25))
        sizer.Add(self.gauge, 0, wx.ALL | wx.EXPAND, 10)

        # Cancel button
        if self._future_holder is not None:
            cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Cancel")
            sizer.Add(cancel_btn, 0, wx.ALL | wx.ALIGN_CENTER, 10)
            cancel_btn.Bind(wx.EVT_BUTTON, self._on_cancel)

        panel.SetSizer(sizer)
        sizer.Fit(self)
        self.Centre()

        # Timer for pulsing the gauge
        self.timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self._on_timer)
        self.timer.Start(50)  # Update every 50ms

    def _on_timer(self, event: wx.Event) -> None:
        """Update the progress gauge to show activity."""
        self.gauge.Pulse()

    def _on_cancel(self, event: wx.Event) -> None:
        """Cancel the ongoing parking move and close the dialog."""
        if self._future_holder.future:
            self._future_holder.future.cancel()
        else:
            return  # No future to cancel, just ignore the cancel request
        logging.warning("Cancelled parking move")
        self.timer.Stop()
        self.EndModal(wx.ID_CANCEL)

    def close_dialog(self) -> None:
        """Stop the timer and close the dialog."""
        self.timer.Stop()
        self.EndModal(wx.ID_OK)


def park_mirror_with_gui() -> int:
    """
    Park the mirror with GUI confirmation and progress display.

    :return: Exit code (0 for success, non-zero for errors)
    """
    app = wx.App()

    # Show confirmation dialog
    result = wx.MessageBox(
        "Do you want to park the mirror?\n\n"
        "This will move the mirror to its parked position.",
        "Park Mirror Confirmation",
        wx.YES_NO | wx.ICON_QUESTION
    )

    if result != wx.YES:
        logging.info("User cancelled mirror parking")
        app.Destroy()
        return 1

    # Shared state
    state = ParkState()  # holds the current future (for cancellation) and any exception raised

    # Create progress dialog
    dlg = ProgressDialog(future_holder=state)

    def park_thread():
        """Thread function to park the mirror."""
        try:
            do_park_mirror(state)
        except CancelledError as e:
            state.error = e
        except Exception as e:
            logging.exception("Unexpected error while parking mirror")
            state.error = e
        finally:
            # Close dialog on main thread, if not already closed by Cancel
            if dlg.IsShown():
                wx.CallAfter(dlg.close_dialog)

    # Start parking in background thread
    thread = threading.Thread(target=park_thread, daemon=True)
    thread.start()

    # Show modal dialog (blocks until closed by park_thread or Cancel button)
    modal_result = dlg.ShowModal()
    dlg.Destroy()

    # Wait for thread to complete
    thread.join(timeout=2.0)
    if thread.is_alive():
        logging.warning("Parking thread is still running after dialog closed.")

    # Determine outcome
    ex = state.error
    if modal_result == wx.ID_CANCEL or isinstance(ex, CancelledError):
        wx.MessageBox(
            "Mirror parking was cancelled.",
            "Cancelled",
            wx.OK | wx.ICON_INFORMATION
        )
        ret = 1
    elif ex:
        wx.MessageBox(
            f"Error while attempting to park the mirror: {str(ex)}",
            "Error",
            wx.OK | wx.ICON_ERROR
        )
        ret = 130
    else:
        # No need for a success window, the user does see the mirror has moved.
        ret = 0

    app.Destroy()
    return ret


def main(args):
    """
    Handles the command line arguments

    :param args: List of arguments passed
    :return: Value to return to the OS as program exit code
    """

    # arguments handling
    parser = argparse.ArgumentParser(prog="odemis-park-mirror",
                        description="Attempt to park the mirror of the SPARCv2")

    parser.add_argument("--log-level", dest="loglev", metavar="<level>", type=int,
                        default=1, help="set verbosity level (0-2, default = 1)")
    parser.add_argument("--no-gui", dest="no_gui", action="store_true",
                        help="run in CLI mode without GUI confirmation")

    options = parser.parse_args(args[1:])

    # Set up logging before everything else
    if options.loglev < 0:
        logging.error("Log-level must be positive.")
        return 127
    loglev_names = (logging.WARNING, logging.INFO, logging.DEBUG)
    loglev = loglev_names[min(len(loglev_names) - 1, options.loglev)]
    logging.getLogger().setLevel(loglev)

    # Choose GUI or CLI mode
    if options.no_gui:
        # CLI mode - original behavior
        try:
            do_park_mirror()
        except (KeyboardInterrupt, CancelledError):
            logging.info("Interrupted before the end of the execution")
            return 1
        except ValueError as exp:
            logging.error("%s", exp)
            return 127
        except IOError as exp:
            logging.error("%s", exp)
            return 129
        except Exception:
            logging.exception("Unexpected error while performing action.")
            return 130

        return 0
    else:
        # GUI mode
        return park_mirror_with_gui()


if __name__ == '__main__':
    ret = main(sys.argv)
    exit(ret)
